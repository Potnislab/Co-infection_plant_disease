### Figure 1_disease severity_AUDPC

##This code has been adopted from Schandry, 2017 and modified for the current dataset parameters.
#Schandry, N. 2017. A Practical guide to visualization and statistical analysis of R. solanacearum infection data using R. Front. Plant Sci. 8 


## Reading data and formatting

#The data can be read into *R* and stored in a data frame. I am calling that data frame disease.index

#wd to set working directory. 
setwd(wd)

#input file: DIndexhigh.csv; contains data for different experimental batches, with experiment data for high humidity.
DIndexhigh <- read.csv("DIndexhigh.csv")

di_coinfection <- as.data.frame(DIndexhigh)


#Using str() one can see if the tables were properly imported.

#````{r inspect structure}


str(di_coinfection)

#If the table was properly imported, "Xnumber" columns should be either numeric, or logical (if they were empty).
#If this is the case, generation of a "subject"" column helps further analysis, which assings a unique, numeric identifier to each individual.

di_coinfection$subject <- c(1:nrow(di_coinfection))



#Install and load all required packages
library(MESS)
library(lme4)
library(lmerTest)
library(multcomp)
library(survival)
library(rms)
library(coxme)
library(stargazer)
library(survcomp)
library(tidyverse)
library(rcompanion)

#These tables need to be made long.

#````{r load tidyr, message=F}
library("tidyr")

#Now, the table of disease index recordings, needs to converted into long format for later analysis, conforming with a data structure often referred to as "tidy" (Wickham, 2008) . Long format means, that instead of having one column of each day, a new column is generated that indicates the day post infection (DPI). 

#my data imported is already in format where one column called as DPI has all disease index values.

# Next, some modifications the table structure are neccessary to make sure that all variables (columns) are in the proper format.

di_coinfection$DI <- as.numeric(di_coinfection$DI) ###Turns DI into numeric


#Now, it is time to generate the "subject" variable, unique for each subject. A unique identifier can be generated by combining information from Strain, Replicate and Batch. 


di_coinfection$subject <- interaction(di_coinfection$Strain, di_coinfection$Replicate, di_coinfection$Batch)



###Factorize batch information
di_coinfection$Batch <- as.factor(di_coinfection$Batch)



##Defining the contrasts

#A crucial step that will influence all outputs of the statistical analysis is setting the "contrasts". Contrasts specifies the "baseline" for each of the variables. "Treatment" contrasts specify that the first alphabetical level will be used as a reference for all others (see Strain below), while a "sum" constrast means that the reference value is the mean across all levels of that variable.


#{r contrasts}
####Specify what should be "appropriate" contrasts
contrasts(di_coinfection$Strain) <- "contr.treatment"###First alphabetical strain will be the baseline
attr (di_coinfection$Strain, "contrasts") <- contr.poly
contrasts(di_coinfection$Batch) <- "contr.sum" ###Batches will be averaged to generate the baseline!






## Table quality check


library("broom.mixed")


str(di_coinfection)
tidy(di_coinfection) ###This can be used to assess the descriptive statistics of the data.




#Table export


write.csv(di_coinfection, file = "di_coinfection.csv")




#Session Info

sessionInfo()



###Name of the file to be read
di_long <- read.table("di_coinfection.csv", sep=",", header=T)

di_long

###Redefine the variables
di_long$Batch <- as.factor(di_long$Batch)
contrasts(di_long$Strain) <- "contr.treatment"###First alphabetical strain will be the baseline!
contrasts(di_long$Batch) <- "contr.sum" ###Batches will be averaged to generate the baseline!



#Analysis of AUDPC

##Rationale and data preparation



library("dplyr")


di_summary <- di_long %>% group_by(Strain, Batch, DPI) %>% 
  summarise(mean(DI),sd(DI),sd(DI)/sqrt(length(DI))) ##calculate within Batch mean, sd, and se for each Plant/Strain combination.
##Averages within each replicate. This summary table is mainly helpful for plotting, not used for analysis...
colnames(di_summary) <- c("Strain", "Batch", "DPI", "mean", "sd", "se") ###Assign correct columnnames

di_summary

#Using these summaries, one can take a look at the averaged disease progression, using


library("ggplot2")

#{r plot disease area from summary}

ggplot(filter(di_summary, Batch==di_summary$Batch[[1]])) + ###Use Only Batch A (too busy otherwise)
  aes(x=DPI,y=mean,color=Strain) + ###Color by Strain, specify x and y.
  geom_area(aes(fill=Strain),position="identity",alpha=0.15) + ###Area plot, colored by Strain
  ##geom_errorbar(aes(x=DPI, ymax=mean+se, ymin=mean-se), size=0.25)+ ###This line adds SE. 
  ##geom_errorbar(aes(x=DPI, ymax=mean+sd, ymin=mean-sd), size=0.25)+ ###This line adds SD. Don't use both.
  facet_grid(~Strain) + ###One plot per strain 
  labs(x = "Days post infection", y = "Avg. Disease Index") + #Labels
  ggtitle("Disease Areas,\nper strain, for batch 1") #Title


#From this plot, one can see that in the example dataset the areas differ quite drastically between different strains. As can be seen here, all observations can be included in an AUDCP analysis, but one should take care that total observation times are similar, identical if possible. As the area increases with both, increased disease index and prolonged time, experiments of different length should not be compared using this approach.

#To calculated the actual AUDPC for each individual in the dataset a new data frame is created. As AUDCP is calculated from both disease index and DPI, this can not be stored in a reasonable way in the long data frame generated earlier.

#*Change*: Modified subject selection to include as.numeric(). Here, the subjects are based on interaction, hence have character names. Each level of this corresponds to a number, so this can be used for iteration in the loop below.

#{r load MESS, message=F}
library("MESS")
di_long

#{r make auc_df}
####Build a table of AUDPCs, per subject
auc_df <- data.frame() ###Make auc_df data frame
for (i in 1:max(as.numeric(di_long$subject))) { ##Go by subject
  temp <- di_long[as.numeric(di_long$subject)==i,] ###Subset full table into the subject table
  temp <- droplevels(temp) ###Drop levels, so levels works properly below
  auc_df[i,1] <- i ###Subject number
  auc_df[i,2] <- levels(temp$Strain) ###Strain
  auc_df[i,3] <- levels(temp$Batch)###Batch
  auc_df[i,4] <- auc(temp$DPI,temp$DI)} ###AUC; i assume that trapezoid rule is fine here. 
### Additionally, auc calculation starts with the lowest x (DPI). I think this is sensible
### I assume that if one specifies "from=0", the curve is expanded by a triangle that covers the range from 
### 0 to whatever is the value at the first observation. I think the first observation should ideally be 0
### if data was recorded from the beginning..

colnames(auc_df) <- c("subject","Strain","Batch","AUC") ###Name columns in AUC datafarame
auc_df$Strain <- as.factor(auc_df$Strain) #refactor
auc_df$Batch <- as.factor(auc_df$Batch) #refactor
str(auc_df)


#The auc data.frame contains one area under the curve per subject and all other subject specific variables as stored in the original table.

##Analysis of differences in area under the disease progression curve

#An initial assessment of strain specific differences in AUDPC can be performed visually, for example by generating boxpots.

#{r boxplot of auc}
ggplot(auc_df) + geom_boxplot(
  aes(x=Strain, y=AUC, color=Strain),  #Plot boxplots of AUCs, by strains
  notch=F) +
  labs(y="AUDPC") +
  facet_wrap(~Batch) + ###Individual plots per batch (and plant if applicable)
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  ggtitle("Area Under the Disease Progression Curve per strain across batches")


#Next, one can use the area under the disease progression curve, to build a linear model, or a linear mixed effects model.

#```{r load lm4 and lmerTest, message=F}
library("lme4")
library("lmerTest")

#{r analysis AUC}
summary(lm(AUC~Batch,data=auc_df)) ###Can be used to identify batch effects. If there are none, including batch as a random factor below is not necessary (but also not necessarily wrong).

auc_lmer <- lmer(
  AUC ~ Strain + (1|Batch),   ### AUC modeled as a function of strain, random effects of batch 
  data=auc_df) #Linear mixed effects model.

auc_lm <- lm(AUC~Strain+Batch,data=auc_df) #Linear model.

AIC(auc_lm,auc_lmer) #Lower AIC, better fit, linear mixed model is slightly better for this data.
ggplot(data=auc_df, aes(y=AUC, x=Strain)) +geom_boxplot(aes(colour=Batch)) + ggtitle("Boxplot of AUDPC per strain by experimental batch")


#Also in this dataset, effects from Replication are observed.  

#The model can be explored using various functions, such as summary.

library("broom.mixed")
summary(auc_lmer)  ### A model summary, containing information on the model.
tidy(auc_lmer) ### A cleaner display using tidy.

###The tidy output explained:
#Term: A discription: (Intercept) overall intercept. Intercept depends on the contrasts set initially. Here treatment contrasts are used, so Intercept = First alphabetical strain (Strain1).
#StrainStrain2: Difference in the estimate (slope), between Strain2 and the (Intercept)

##Estimate: The estimated slope



#For example, we see the estimated slopes (Estimate) and standard errors, together with a t- and corresponding p-value in the output of the summary function. Note, that the above only contains information on differences between different levels and the "baseline"", which is called (Intercept).  The baseline is determined by the contrast settings that were specified earlier.

#But, it may be quite relevant to know how individual strains compare to each other (and not just how each strain compares to Strain1). This can be analyzed using a generalized linear hypothesis test, while ajusting for multiple comparisons using Tukey's method.


library("multcomp")
library("rcompanion")
library("stringr")

tidy(summary(glht(auc_lmer, linfct=mcp(Strain="Tukey"))))


#This information can, for example, be integrated into a boxplot of the individual disease areas. Using a compact letter display, in conbination with AUDPC, combines statistical and visual information.

#{r AUC model CLD plot}
auc_cld <- cld(glht(auc_lmer, linfct=mcp(Strain="Tukey"))) ###Save letters
auc_cld <- cbind(levels(auc_df$Strain),auc_cld$mcletters$Letters) ###bind letters to columns
colnames(auc_cld) <- c("Strain","Letter") ###Name columns
auc_cld <- as.data.frame(auc_cld) #Coerce to dataframe
auc_cld
###Integrate letters into auc_df##
auc_df <- left_join(auc_df,auc_cld,by="Strain",copy=T) ###Add letter information
auc_df
###Some extra scripting to make the mean and CI plot.
summary(auc_lmer)
auc_CI <- as.data.frame(confint_tidy(auc_lmer))
auc_CI
auc_CI <- auc_CI[2:nrow(auc_CI),] ##Drop sig01, sigma
auc_CI
auc_CI$Strain <- levels(auc_df$Strain)
auc_CI

###Mean relative to Strain1 (except strain1 that one is absolute)

for (i in 1:nrow(auc_CI)){
  if (i==1){
    auc_CI$mean[i] <- mean(c(auc_CI$X2.5..[i],auc_CI$X97.5..[i]))
    auc_CI$upr[i] <- auc_CI$X97.5..[i]
    auc_CI$lwr[i] <- auc_CI$X2.5..[i]
  } else {
    auc_CI$mean[i] <- c(auc_CI$mean[1]+mean(c(auc_CI$X2.5..[i],auc_CI$X97.5..[i])))
    auc_CI$upr[i] <- c(auc_CI$mean[1]+auc_CI$X97.5..[i])
    auc_CI$lwr[i] <- c(auc_CI$mean[1]+auc_CI$X2.5..[i])
  }
}

auc_CI$upr

####Generate plot of meanCI of AUDCP with significance letters and raw data as jittered points
ggplot(aes(x=Strain, y=AUC, color=Strain),data=auc_df) +###Plot the auc_df
  geom_jitter(aes(shape=Batch)) + ###with jitter overplotted, symbol shape defined by batch
  geom_text(aes(x=Strain, y=9, label=Letter),color="black", data=auc_cld) + ###Get the letters from auc_cld 
  #and write those to position y=-3
  labs(y="AUDPC") + #Y-Axis label 
  ylim(8,55) +
  ggtitle("AUDPC raw values and mean from the LMM\nwith 95% CI per strain and grouping letters") #Title 

ggsave("AUDPC_high_LMM.tiff")




#Now, run the same above code for low humidity data
DIndexlow <- read.csv("DIndexlow.csv")

di_coinfection <- as.data.frame(DIndexlow)


#Using str() one can see if the tables were properly imported.

#````{r inspect structure}


str(di_coinfection)

#If the table was properly imported, "Xnumber" columns should be either numeric, or logical (if they were empty).
#If this is the case, generation of a "subject"" column helps further analysis, which assings a unique, numeric identifier to each individual.

di_coinfection$subject <- c(1:nrow(di_coinfection))



#Install and load all required packages
library(MESS)
library(lme4)
library(lmerTest)
library(multcomp)
library(survival)
library(rms)
library(coxme)
library(stargazer)
library(survcomp)
library(tidyverse)
library(rcompanion)

#These tables need to be made long.

#````{r load tidyr, message=F}
library("tidyr")

#Now, the table of disease index recordings, needs to converted into long format for later analysis, conforming with a data structure often referred to as "tidy" (Wickham, 2008) . Long format means, that instead of having one column of each day, a new column is generated that indicates the day post infection (DPI). 

#my data imported is already in format where one column called as DPI has all disease index values.

# Next, some modifications the table structure are neccessary to make sure that all variables (columns) are in the proper format.

di_coinfection$DI <- as.numeric(di_coinfection$DI) ###Turns DI into numeric


#Now, it is time to generate the "subject" variable, unique for each subject. A unique identifier can be generated by combining information from Strain, Replicate and Batch. 


di_coinfection$subject <- interaction(di_coinfection$Strain, di_coinfection$Replicate, di_coinfection$Batch)



###Factorize batch information
di_coinfection$Batch <- as.factor(di_coinfection$Batch)



##Defining the contrasts

#A crucial step that will influence all outputs of the statistical analysis is setting the "contrasts". Contrasts specifies the "baseline" for each of the variables. "Treatment" contrasts specify that the first alphabetical level will be used as a reference for all others (see Strain below), while a "sum" constrast means that the reference value is the mean across all levels of that variable.


#{r contrasts}
####Specify what should be "appropriate" contrasts
contrasts(di_coinfection$Strain) <- "contr.treatment"###First alphabetical strain will be the baseline
attr (di_coinfection$Strain, "contrasts") <- contr.poly
contrasts(di_coinfection$Batch) <- "contr.sum" ###Batches will be averaged to generate the baseline!






## Table quality check


library("broom.mixed")


str(di_coinfection)
tidy(di_coinfection) ###This can be used to assess the descriptive statistics of the data.




#Table export


write.csv(di_coinfection, file = "di_coinfection_low.csv")




#Session Info

sessionInfo()



###Name of the file to be read
di_long <- read.table("di_coinfection_low.csv", sep=",", header=T)

di_long <- di_coinfection

###Redefine the variables
di_long$Batch <- as.factor(di_long$Batch)
contrasts(di_long$Strain) <- "contr.treatment"###First alphabetical strain will be the baseline!
contrasts(di_long$Batch) <- "contr.sum" ###Batches will be averaged to generate the baseline!



#Analysis of AUDPC

##Rationale and data preparation



library("dplyr")


di_summary <- di_long %>% group_by(Strain, Batch, DPI) %>% 
  summarise(mean(DI),sd(DI),sd(DI)/sqrt(length(DI))) ##calculate within Batch mean, sd, and se for each Plant/Strain combination.
##Averages within each replicate. This summary table is mainly helpful for plotting, not used for analysis...
colnames(di_summary) <- c("Strain", "Batch", "DPI", "mean", "sd", "se") ###Assign correct columnnames

di_summary

#Using these summaries, one can take a look at the averaged disease progression, using


library("ggplot2")

#{r plot disease area from summary}

ggplot(filter(di_summary, Batch==di_summary$Batch[[1]])) + ###Use Only Batch A (too busy otherwise)
  aes(x=DPI,y=mean,color=Strain) + ###Color by Strain, specify x and y.
  geom_area(aes(fill=Strain),position="identity",alpha=0.15) + ###Area plot, colored by Strain
  ##geom_errorbar(aes(x=DPI, ymax=mean+se, ymin=mean-se), size=0.25)+ ###This line adds SE. 
  ##geom_errorbar(aes(x=DPI, ymax=mean+sd, ymin=mean-sd), size=0.25)+ ###This line adds SD. Don't use both.
  facet_grid(~Strain) + ###One plot per strain 
  labs(x = "Days post infection", y = "Avg. Disease Index") + #Labels
  ggtitle("Figure 1\nDisease Areas,\nper strain, for batch A") #Title


#From this plot, one can see that in the example dataset the areas differ quite drastically between different strains. As can be seen here, all observations can be included in an AUDCP analysis, but one should take care that total observation times are similar, identical if possible. As the area increases with both, increased disease index and prolonged time, experiments of different length should not be compared using this approach.

#To calculated the actual AUDPC for each individual in the dataset a new data frame is created. As AUDCP is calculated from both disease index and DPI, this can not be stored in a reasonable way in the long data frame generated earlier.

#*Change*: Modified subject selection to include as.numeric(). Here, the subjects are based on interaction, hence have character names. Each level of this corresponds to a number, so this can be used for iteration in the loop below.

#{r load MESS, message=F}
library("MESS")
di_long

#{r make auc_df}
####Build a table of AUDPCs, per subject
auc_df <- data.frame() ###Make auc_df data frame
for (i in 1:max(as.numeric(di_long$subject))) { ##Go by subject
  temp <- di_long[as.numeric(di_long$subject)==i,] ###Subset full table into the subject table
  temp <- droplevels(temp) ###Drop levels, so levels works properly below
  auc_df[i,1] <- i ###Subject number
  auc_df[i,2] <- levels(temp$Strain) ###Strain
  auc_df[i,3] <- levels(temp$Batch)###Batch
  auc_df[i,4] <- auc(temp$DPI,temp$DI)} ###AUC; i assume that trapezoid rule is fine here. 
### Additionally, auc calculation starts with the lowest x (DPI). I think this is sensible
### I assume that if one specifies "from=0", the curve is expanded by a triangle that covers the range from 
### 0 to whatever is the value at the first observation. I think the first observation should ideally be 0
### if data was recorded from the beginning..

colnames(auc_df) <- c("subject","Strain","Batch","AUC") ###Name columns in AUC datafarame
auc_df$Strain <- as.factor(auc_df$Strain) #refactor
auc_df$Batch <- as.factor(auc_df$Batch) #refactor
str(auc_df)


#The auc data.frame contains one area under the curve per subject and all other subject specific variables as stored in the original table.

##Analysis of differences in area under the disease progression curve

#An initial assessment of strain specific differences in AUDPC can be performed visually, for example by generating boxpots.

#{r boxplot of auc}
ggplot(auc_df) + geom_boxplot(
  aes(x=Strain, y=AUC, color=Strain),  #Plot boxplots of AUCs, by strains
  notch=F) +
  labs(y="AUDPC") +
  facet_wrap(~Batch) + ###Individual plots per batch (and plant if applicable)
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  ggtitle("Figure 2\nArea Under the Disease Progression Curve per strain across batches")


#Next, one can use the area under the disease progression curve, to build a linear model, or a linear mixed effects model.

#```{r load lm4 and lmerTest, message=F}
library("lme4")
library("lmerTest")

#{r analysis AUC}
summary(lm(AUC~Batch,data=auc_df)) ###Can be used to identify batch effects. If there are none, including batch as a random factor below is not necessary (but also not necessarily wrong).

auc_lmer <- lmer(
  AUC ~ Strain + (1|Batch),   ### AUC modeled as a function of strain, random effects of batch 
  data=auc_df) #Linear mixed effects model.

auc_lm <- lm(AUC~Strain+Batch,data=auc_df) #Linear model.

AIC(auc_lm,auc_lmer) #Lower AIC, better fit, linear mixed model is slightly better for this data.
ggplot(data=auc_df, aes(y=AUC, x=Strain)) +geom_boxplot(aes(colour=Batch)) + ggtitle("Boxplot of AUDPC per strain by experimental batch")


#Also in this dataset, effects from Replication are observed.  

#The model can be explored using various functions, such as summary.

library("broom.mixed")
summary(auc_lmer)  ### A model summary, containing information on the model.
tidy(auc_lmer) ### A cleaner display using tidy.

###The tidy output explained:
#Term: A discription: (Intercept) overall intercept. Intercept depends on the contrasts set initially. Here treatment contrasts are used, so Intercept = First alphabetical strain (Strain1).
#StrainStrain2: Difference in the estimate (slope), between Strain2 and the (Intercept)

##Estimate: The estimated slope



#For example, we see the estimated slopes (Estimate) and standard errors, together with a t- and corresponding p-value in the output of the summary function. Note, that the above only contains information on differences between different levels and the "baseline"", which is called (Intercept).  The baseline is determined by the contrast settings that were specified earlier.

#But, it may be quite relevant to know how individual strains compare to each other (and not just how each strain compares to Strain1). This can be analyzed using a generalized linear hypothesis test, while ajusting for multiple comparisons using Tukey's method.


library("multcomp")
library("rcompanion")
library("stringr")

tidy(summary(glht(auc_lmer, linfct=mcp(Strain="Tukey"))))


#This information can, for example, be integrated into a boxplot of the individual disease areas. Using a compact letter display, in conbination with AUDPC, combines statistical and visual information.

#{r AUC model CLD plot}
auc_cld <- cld(glht(auc_lmer, linfct=mcp(Strain="Tukey"))) ###Save letters
auc_cld <- cbind(levels(auc_df$Strain),auc_cld$mcletters$Letters) ###bind letters to columns
colnames(auc_cld) <- c("Strain","Letter") ###Name columns
auc_cld <- as.data.frame(auc_cld) #Coerce to dataframe
auc_cld
###Integrate letters into auc_df##
auc_df <- left_join(auc_df,auc_cld,by="Strain",copy=T) ###Add letter information
auc_df
###Some extra scripting to make the mean and CI plot.
summary(auc_lmer)
auc_CI <- as.data.frame(confint_tidy(auc_lmer))
auc_CI
auc_CI <- auc_CI[2:nrow(auc_CI),] ##Drop sig01, sigma
auc_CI
auc_CI$Strain <- levels(auc_df$Strain)
auc_CI

###Mean relative to Strain1 (except strain1 that one is absolute)

for (i in 1:nrow(auc_CI)){
  if (i==1){
    auc_CI$mean[i] <- mean(c(auc_CI$X2.5..[i],auc_CI$X97.5..[i]))
    auc_CI$upr[i] <- auc_CI$X97.5..[i]
    auc_CI$lwr[i] <- auc_CI$X2.5..[i]
  } else {
    auc_CI$mean[i] <- c(auc_CI$mean[1]+mean(c(auc_CI$X2.5..[i],auc_CI$X97.5..[i])))
    auc_CI$upr[i] <- c(auc_CI$mean[1]+auc_CI$X97.5..[i])
    auc_CI$lwr[i] <- c(auc_CI$mean[1]+auc_CI$X2.5..[i])
  }
}

auc_CI$upr

####Generate plot of meanCI of AUDPC with significance letters and raw data as jittered points
ggplot(aes(x=Strain, y=AUC, color=Strain),data=auc_df) +###Plot the auc_df
  geom_jitter(aes(shape=Batch)) + ###with jitter overplotted, symbol shape defined by batch
  geom_text(aes(x=Strain, y=9, label=Letter),color="black", data=auc_cld) + ###Get the letters from auc_cld 
  #and write those to position y=-3
  labs(y="AUDPC") + #Y-Axis label 
  ylim(8,55) +
  ggtitle("AUDPC raw values and mean from the LMM\nwith 95% CI per strain and grouping letters") #Title 

ggsave("AUDPC_low_LMM.tiff")